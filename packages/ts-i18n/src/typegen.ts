import type { TranslationTree } from './types'
import { mkdir, writeFile } from 'node:fs/promises'
import { dirname } from 'node:path'

function collectKeys(tree: TranslationTree, prefix = ''): string[] {
  const keys: string[] = []
  for (const [k, v] of Object.entries(tree)) {
    const full = prefix ? `${prefix}.${k}` : k
    if (v && typeof v === 'object' && !Array.isArray(v))
      keys.push(...collectKeys(v as TranslationTree, full))
    else keys.push(full)
  }
  return keys
}

export async function generateTypes(treesByLocale: Record<string, TranslationTree>, outFile: string): Promise<void> {
  const locales = Object.keys(treesByLocale)
  if (locales.length === 0) {
    await mkdir(dirname(outFile), { recursive: true })
    await writeFile(outFile, 'export type TranslationKey = string\n')
    return
  }

  const baseLocale = locales[0]
  const baseTree = treesByLocale[baseLocale]
  const keys = collectKeys(baseTree).sort()
  const union = keys.map(k => JSON.stringify(k)).join(' | ')
  const dts = `export type TranslationKey = ${union}\n`
  await mkdir(dirname(outFile), { recursive: true })
  await writeFile(outFile, dts)
}

/**
 * Generate declaration file that infers keys and params from a TS module that exports the base locale tree.
 * The module should export default (or named `translations`) object satisfying `TranslationTree`.
 * Example usage: generateTypesFromModule('locales/en/index.ts', 'dist/i18n/keys.d.ts')
 */
export async function generateTypesFromModule(modulePath: string, outFile: string, _exportedName?: string): Promise<void> {
  const content = `// Auto-generated by ts-i18n. Do not edit.
import type { DotPaths, ParamsForKey, TranslatorFor } from 'ts-i18n'
import * as Mod from ${JSON.stringify(modulePath)}

type Base = (
  Mod extends { default: infer D } ? D :
  Mod extends { translations: infer T } ? T :
  Mod
) extends infer X ? X : never

export type TranslationKey = DotPaths<Base>
export type ParamsFor<K extends TranslationKey> = ParamsForKey<Base, K>
export type TypedTranslator = TranslatorFor<Base>
`
  await mkdir(dirname(outFile), { recursive: true })
  await writeFile(outFile, content)
}
